use chrono::{DateTime, Local, Utc};
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct ConversationOverview {
    pub id: u64,
    pub subject: String,
    #[serde(alias = "workflow_state")]
    pub state: ConversationState,
    #[serde(alias = "last_message")]
    pub preview: String,
    pub audience: Vec<u64>,
    pub last_message_at: DateTime<Utc>,
    pub message_count: u64,
    pub subscribed: bool,
    pub private: bool,
    pub starred: bool,
    pub participants: Vec<ConversationParticipant>,
    pub context_name: String,
}

impl std::cmp::PartialEq for ConversationOverview {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl crate::types::ResponseType for ConversationOverview {}

impl std::fmt::Display for ConversationOverview {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "[{}] {}", self.id, self.subject)
    }
}

#[derive(Debug, Deserialize)]
pub struct Conversation {
    pub id: u64,
    pub subject: String,
    #[serde(alias = "workflow_state")]
    pub state: ConversationState,
    #[serde(alias = "last_message")]
    pub preview: String,
    pub audience: Vec<u64>,
    pub last_message_at: DateTime<Utc>,
    pub message_count: u64,
    pub subscribed: bool,
    pub private: bool,
    pub starred: bool,
    pub participants: Vec<ConversationParticipant>,
    pub messages: Vec<ConversationMessage>,
}

impl std::cmp::PartialEq for Conversation {
    fn eq(&self, other: &Self) -> bool {
        self.id == other.id
    }
}
impl crate::types::ResponseType for Conversation {}

#[derive(Debug, Deserialize)]
pub struct ConversationMessage {
    pub id: u64,
    pub body: String,
    pub author_id: u64,
    pub generated: bool,
    // pub media_comment: Option<()>,
    pub forwarded_messages: Option<Vec<ConversationMessage>>,
    pub attachments: Option<Vec<ConversationAttachment>>,
}

#[derive(Debug, Deserialize)]
pub struct ConversationAttachment {
    pub id: u64,
    pub display_name: String,
    #[serde(alias = "content-type")]
    pub content_type: String, // MIME type
    pub filename: String,
    pub url: String,
}

#[derive(Debug, Deserialize)]
pub struct ConversationParticipant {
    pub id: u64,
    pub name: String,
    pub full_name: String,
}

#[derive(Debug, Deserialize, PartialEq)]
pub struct UnreadCount {
    pub unread_count: u64,
}

impl crate::types::ResponseType for UnreadCount {}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ConversationState {
    Read,
    Unread,
    Archived,
}

impl super::Viewable for ConversationMessage {
    fn view(&self, _: &fuller_config::Config) -> String {
        format!(
            "
Author: {}
Autogenerated? {}

{}

===================",
            self.author_id, self.generated, self.body,
        )
    }
}

impl super::Viewable for Conversation {
    fn view(&self, config: &fuller_config::Config) -> String {
        let sent_at = format!(
            "Sent At: {}",
            DateTime::<Local>::from(self.last_message_at).format(&crate::datetime_format(config))
        );
        let messages = self
            .messages
            .iter()
            .fold("===================".to_owned(), |acc, x| {
                format!("{acc}\n{}", x.view(config))
            });
        let participants = display_vec(
            self.participants.iter().map(|x| &x.name).collect(),
            config.formatting.max_width,
        );
        format!(
            "[{}] ({}) {}\n\n{}\n\n{}", // TODO: Investigate formatting w/ termcolor
            self.id, sent_at, self.subject, participants, messages,
        )
    }
}

fn display_vec(vec: Vec<impl std::fmt::Display>, max_width: usize) -> String {
    let mut res_str: String;
    if let Some(initial_value) = vec.first() {
        res_str = initial_value.to_string();
    } else {
        return String::default();
    }

    let mut line_index = 0;
    for v in vec[1..].iter() {
        // newline if 80 chars
        let new_string = v.to_string();
        if res_str.len() + new_string.len() + 2 - line_index >= max_width {
            res_str.push_str(",\n");
            line_index = res_str.len();

            res_str.push_str(&new_string);
        } else {
            res_str.push_str(&format!(", {}", new_string));
        }
    }

    res_str
}
